package tract

import (
	"context"
	"time"
)

// Request is the object that is passed along the tract.
// It keeps track of state by storing data via context values
type Request[T any] struct{
	Ctx context.Context
	Data T
}

// requestTimeStart is the key to retreive the generation time from a request.
// Request value type is time.Time
type requestTimeStartKey struct{}

// GetRequestStartTime get the time the request was generated.
// If there is no start time, the zero value of time.Time is returned.
func GetRequestStartTime[T any](r *Request[T]) time.Time {
	startTime, _ := r.Ctx.Value(requestTimeStartKey{}).(time.Time)
	return startTime
}

func setRequestStartTime[T any](r *Request[T], t time.Time) *Request[T] {
	r.Ctx = context.WithValue(r.Ctx, requestTimeStartKey{}, t)
	return r
}

// Request value type is cleanups
type cleanupKey struct{}
type cleanups[T any] []func(r *Request[T], success bool)

// AddRequestCleanup add a function to the request that will be run when the request dies.
// This happens either when it reaches the end of a pool with no user set output, or a worker
// specified that the request should no longer continue.
func AddRequestCleanup[T any](r *Request[T], f func(*Request[T], bool)) *Request[T] {
	if f == nil {
		return r
	}
	cleanupFuncs, _ := r.Ctx.Value(cleanupKey{}).(cleanups[T])
	cleanupFuncs = append(cleanupFuncs, f)
	r.Ctx = context.WithValue(r.Ctx, cleanupKey{}, cleanupFuncs)
	return r
}

// RemoveAllRequestCleanups removes all of the cleanups attached to the request.
// This does not run the cleanups.
func RemoveAllRequestCleanups[T any](r *Request[T]) *Request[T] {
	r.Ctx = context.WithValue(r.Ctx, cleanupKey{}, nil)
	return r
}

// CleanupRequest manually calls all the cleanup functions attached to the request.
// This does not remove the cleanups.
func CleanupRequest[T any](r *Request[T], success bool) {
	cleanupRequest(r, success)
}

func cleanupRequest[T any](r *Request[T], success bool) {
	cleanupFuncs, _ := r.Ctx.Value(cleanupKey{}).(cleanups[T])
	for _, f := range cleanupFuncs {
		f(r, success)
	}
}

// swapCleanups sets the request cleanup ot be the provided cleanup, and retunrs the old cleanup.
func swapCleanups[T any](ctx context.Context, cleanupFuncs cleanups[T]) (context.Context, cleanups[T]) {
	oldCleaupFuncs, _ := ctx.Value(cleanupKey{}).(cleanups[T])
	ctx = context.WithValue(ctx, cleanupKey{}, cleanupFuncs)
	return ctx, oldCleaupFuncs
}
